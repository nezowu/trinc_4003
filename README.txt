# trinc_4003
Эмулятор троичного компьютера.

Филосовские размышления о жизни дают основание полагать что основа
бытия является троичной. Базирующейся на трех сущностях - развития
времени и пространства.

Аппаратный стек - используется для хранения адресов возврата из функций и их
аргументов.
Программный стек – это пользовательская модель (структура) данных.


pc - адрес следующей выполняемой опперации
При вызове функции содержимое записывается в регистре возврата или в стеке,
а в pc записывается адресс перехода. (call)
При выполнении (return) 
ps - адрес вершины стека (база стека находится на последнем доступном адресе 81)

В остновном для реализации переходов являющихся частью логических операций.

За наличием небольшой оперативной памяти я решила не выделять в ней адреса
под стек, а создать стек из стопки дополнительных регистров, тогда хоть и
будет утеряна возможность обращатся к стеку по адресу, но
очень удачно будет можно разделить все адрессное пространство на две секции.
В секции text, берущей начало с нулевого адреса и растущей по возростанию адресов
будет загружаться программа с глобальной точкой входа 0, а вторая секция data,
с началом на наибольшем доступном адресе 80 и растущей по убыванию, как стек,
отведем под секцию данных на которые в программе будут создаваться указатели,
в основном это задумано под массивы чисел и строчные данные. Других секций
в памяти не будет.

%ip
%sp
%bp стековый кадр


Программа разбивается на четыре трайта - это один такт.
Первый трайт это номер инструкции.
Второй, третий и четвертый парметры загружаемые в регистры.

Идея!
В память text пишем всю программу,
а в память data пишем структуру
программы - массив из цифр колличества аргументов
в порядке следования тактов. Например при вызове инструкции
push пишем в первый трайт цифру 2 - это будет значить что
в программе один параметр и одна инструкция и к указателю адреса
следующей инструкции регистру IP прибавится 2.
Или еще проще записывать не количество параметров, а сразу начальные
адреса каждой инструкции и разбирать эту стопку загружая в регистр IP
адреса по порядку следования.

Ввод-вывод тарнсляция строчных символов в трайт-код и обратно.
Принимаются все буквы латинского алфавита, цифры, знаки припинания,
основные математические символы, занаки пробела и перевода строки.

Сперва напишем программу на воображаемом ассемблере,
потом распарсим ее(препроцессор) и переведем в байт код.
.section .data
_str name 11 'hello world' //трансляция знаков строки в трайт-код и обратно.
//секция Data, директива <массив>, имя массива которое заменяется адресом из
Data и этот адрес вставляется в места программы где есть имя этой переменной,
рамер массива, строка, если пустая то просто выделить место и записать по
адресу только размер по нулевому индексу.
.section .text

Что бы общаться с эмулируемым процессором в реальном времени, включая
трансляцию между кодами, напишем две функции
осуществляющие сканирование и вывод через терминал ascii cимволов.
Так как предел эмулируемого процессора составляет всего 80 символов,
то немного упростим существующую таблицу
символов, в первую очередь исключим ряд Заглавных букв, сдвинем
все в лево на 31 пункт и оставшиеся за бортом цифры 80, четыре знака,
перенесем на место неиспользованных заглавных символов. У нас даже
осталось около десятка зарезервированных на будущее строковых значений
и мы можем набрать на клаве любой знак из аскии таблицы.
Строковые массивы (и массивы целых чисел находящиеся
в области памяти Data) будут
записываться с указанием в начале своего размера.
Создадаю фунции ввода-вывода на линукс консоль строковых массивов
с переработанными кодами ascii. Размер массива не будет включать
первый, нулевой индекс.
